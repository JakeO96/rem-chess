[{"/home/jake/rem-stack/chess/client/src/index.tsx":"1","/home/jake/rem-stack/chess/client/src/reportWebVitals.ts":"2","/home/jake/rem-stack/chess/client/src/App.tsx":"3","/home/jake/rem-stack/chess/client/src/api/express-api.ts":"4","/home/jake/rem-stack/chess/client/src/pages/HomePage.tsx":"5","/home/jake/rem-stack/chess/client/src/pages/LogInPage.tsx":"6","/home/jake/rem-stack/chess/client/src/components/LogInForm.tsx":"7","/home/jake/rem-stack/chess/client/src/components/MainLayout.tsx":"8","/home/jake/rem-stack/chess/client/src/components/MainHeader.tsx":"9","/home/jake/rem-stack/chess/client/src/components/FormFields.tsx":"10","/home/jake/rem-stack/chess/client/src/pages/UserDashboardPage.tsx":"11","/home/jake/rem-stack/chess/client/src/components/RegisterForm.tsx":"12","/home/jake/rem-stack/chess/client/src/pages/RegisterPage.tsx":"13","/home/jake/rem-stack/chess/client/src/context/AuthContext.tsx":"14","/home/jake/rem-stack/chess/client/src/components/ProtectedRoute.tsx":"15","/home/jake/rem-stack/chess/client/src/components/StartGamePortal.tsx":"16","/home/jake/rem-stack/chess/client/src/pages/ActiveGamePage.tsx":"17","/home/jake/rem-stack/chess/client/src/components/ActiveGame.tsx":"18","/home/jake/rem-stack/chess/client/src/pages/NewUserRedirectVerifyEmail.tsx":"19","/home/jake/rem-stack/chess/client/src/utils/game-utils.ts":"20","/home/jake/rem-stack/chess/client/src/context/GameContext.tsx":"21","/home/jake/rem-stack/chess/client/src/utils/svg-icons.tsx":"22"},{"size":554,"mtime":1688152721958,"results":"23","hashOfConfig":"24"},{"size":425,"mtime":1687374351293,"results":"25","hashOfConfig":"24"},{"size":1875,"mtime":1690851974681,"results":"26","hashOfConfig":"24"},{"size":2829,"mtime":1690086852749,"results":"27","hashOfConfig":"24"},{"size":403,"mtime":1688260808268,"results":"28","hashOfConfig":"24"},{"size":245,"mtime":1689788180322,"results":"29","hashOfConfig":"24"},{"size":5215,"mtime":1689875330530,"results":"30","hashOfConfig":"24"},{"size":372,"mtime":1691640386012,"results":"31","hashOfConfig":"24"},{"size":2146,"mtime":1691639508889,"results":"32","hashOfConfig":"24"},{"size":4980,"mtime":1690608231720,"results":"33","hashOfConfig":"24"},{"size":526,"mtime":1689920191128,"results":"34","hashOfConfig":"24"},{"size":6571,"mtime":1690652897218,"results":"35","hashOfConfig":"24"},{"size":418,"mtime":1689009207632,"results":"36","hashOfConfig":"24"},{"size":2484,"mtime":1691183833849,"results":"37","hashOfConfig":"24"},{"size":563,"mtime":1689874298008,"results":"38","hashOfConfig":"24"},{"size":4721,"mtime":1691609068892,"results":"39","hashOfConfig":"24"},{"size":254,"mtime":1690851990193,"results":"40","hashOfConfig":"24"},{"size":12106,"mtime":1691638828686,"results":"41","hashOfConfig":"24"},{"size":902,"mtime":1690652846174,"results":"42","hashOfConfig":"24"},{"size":11696,"mtime":1691542128148,"results":"43","hashOfConfig":"24"},{"size":3781,"mtime":1691541118869,"results":"44","hashOfConfig":"24"},{"size":13841,"mtime":1691542046407,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},"2lf18s",{"filePath":"50","messages":"51","suppressedMessages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"53","messages":"54","suppressedMessages":"55","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"59","messages":"60","suppressedMessages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"68","messages":"69","suppressedMessages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"71","messages":"72","suppressedMessages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","suppressedMessages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"77","messages":"78","suppressedMessages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"49"},{"filePath":"81","messages":"82","suppressedMessages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"84","messages":"85","suppressedMessages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"87","messages":"88","suppressedMessages":"89","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"90","messages":"91","suppressedMessages":"92","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"93","messages":"94","suppressedMessages":"95","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96"},{"filePath":"97","messages":"98","suppressedMessages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"100"},{"filePath":"101","messages":"102","suppressedMessages":"103","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"104"},{"filePath":"105","messages":"106","suppressedMessages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"49"},{"filePath":"108","messages":"109","suppressedMessages":"110","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"111","messages":"112","suppressedMessages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114"},{"filePath":"115","messages":"116","suppressedMessages":"117","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/jake/rem-stack/chess/client/src/index.tsx",[],[],[],"/home/jake/rem-stack/chess/client/src/reportWebVitals.ts",[],[],"/home/jake/rem-stack/chess/client/src/App.tsx",[],[],"/home/jake/rem-stack/chess/client/src/api/express-api.ts",[],[],"/home/jake/rem-stack/chess/client/src/pages/HomePage.tsx",[],[],"/home/jake/rem-stack/chess/client/src/pages/LogInPage.tsx",[],[],"/home/jake/rem-stack/chess/client/src/components/LogInForm.tsx",[],[],"/home/jake/rem-stack/chess/client/src/components/MainLayout.tsx",[],[],"/home/jake/rem-stack/chess/client/src/components/MainHeader.tsx",[],[],"/home/jake/rem-stack/chess/client/src/components/FormFields.tsx",[],[],"/home/jake/rem-stack/chess/client/src/pages/UserDashboardPage.tsx",["118","119"],[],"import { FC, useEffect, useState } from \"react\";\nimport MainLayout from \"../components/MainLayout\";\nimport ExpressAPI from \"../api/express-api\";\nimport { StartGamePortal } from \"../components/StartGamePortal\";\n\ninterface DashboardPageProps {\n  expressApi: ExpressAPI\n}\n\nexport const DashboardPage: FC<DashboardPageProps> = ({ expressApi }) => {\n\n  return (\n    <MainLayout>\n      <header>\n        <h1>\n          DASHBOARD\n        </h1>\n      </header>\n      <StartGamePortal expressApi={expressApi} />\n    </MainLayout>\n  );\n}","/home/jake/rem-stack/chess/client/src/components/RegisterForm.tsx",[],[],"/home/jake/rem-stack/chess/client/src/pages/RegisterPage.tsx",[],[],"/home/jake/rem-stack/chess/client/src/context/AuthContext.tsx",[],[],"/home/jake/rem-stack/chess/client/src/components/ProtectedRoute.tsx",[],[],"/home/jake/rem-stack/chess/client/src/components/StartGamePortal.tsx",["120"],[],"import { FC, useCallback, useContext, useEffect, useState } from \"react\"\nimport ExpressAPI from \"../api/express-api\";\nimport { Navigate } from \"react-router-dom\";\nimport { AuthContext } from \"../context/AuthContext\";\nimport { GameContext, StartGameMessageObject } from \"../context/GameContext\";\nimport { ReadyState } from \"react-use-websocket\";\nimport { Player } from \"../utils/game-utils\";\n\ninterface StartGamePortalProps {\n  expressApi: ExpressAPI;\n}\n\nexport const StartGamePortal: FC<StartGamePortalProps> = ({ expressApi }) => {\n\n  const [navigateReady, setNavigateReady] = useState<boolean>(false);\n  const [users, setUsers] = useState<string[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const { currentClientUsername } = useContext(AuthContext)\n  const { challenger, opponent, gameId, setGameId, setChallenger, setOpponent, sendMessage, lastMessage, readyState, initiatePlayers } = useContext(GameContext)\n\n  useEffect(() => {\n    expressApi.getLoggedInUsers()\n      .then((res) =>  res.json() )\n      .then((data) => {\n        setUsers(data);\n        setIsLoading(false);\n      })\n      .catch((err) => {\n        console.error(err);\n        setIsLoading(false);\n      });\n  }, [expressApi]);\n\n  useEffect(() => {\n    function handleIncomingData(data: StartGameMessageObject) {\n      if (data.type === 'game-invite') {\n        console.log(data.challenger)\n        console.log(data.opponent)\n        const deserializedChallenger = Player.fromJSON(data.challenger);\n        const accepted = window.confirm(`You have been invited to a game by ${deserializedChallenger.name}. Do you accept?`);\n        const responseMessage = JSON.stringify({ type: 'game-invite-response', accepted, challenger: data.challenger, opponent: data.opponent });\n        sendMessage(responseMessage);\n      } else if (data.type === 'create-game') {\n        expressApi.createGame(data, ((gameId) => {\n          const responseMessage = JSON.stringify({ type: 'game-created', challenger: data.challenger, opponent: data.opponent, gameId: gameId})\n          sendMessage(responseMessage);\n        }))\n      } else if (data.type === 'start-game') {\n        const deserializedOpponent = Player.fromJSON(data.opponent);\n        const deserializedChallenger = Player.fromJSON(data.challenger);\n        console.log('challenger in StartGamePortal start-game response vvv')\n        console.log(deserializedChallenger)\n        console.log('opponent in StartGamePortal start-game response vvv')\n        console.log(deserializedOpponent)\n        setChallenger(deserializedChallenger);\n        setOpponent(deserializedOpponent);\n        if (data.gameId) {\n          setGameId(data.gameId);\n        }\n        setNavigateReady(true);\n      } else if (data.type === 'game-decline') {\n        alert(`${data.initiatingUser} declined to start a game.`);\n      }\n    }\n\n    if (lastMessage !== null) {\n      if (lastMessage.data instanceof Blob) {\n        const reader = new FileReader();\n        reader.onload = () => {\n          if (typeof reader.result === 'string') {\n            const data = JSON.parse(reader.result);\n            handleIncomingData(data);\n          }\n        };\n        reader.readAsText(lastMessage.data);\n      } else {\n        const data = JSON.parse(lastMessage.data);\n        handleIncomingData(data);\n      }\n    }\n  }, [lastMessage, expressApi, sendMessage, setGameId, setChallenger, setOpponent, currentClientUsername, challenger, opponent]);\n\n  const handleUsernameClick = (evt: React.MouseEvent<HTMLButtonElement>) => {\n    const opponentUsername = evt.currentTarget.dataset.username;\n    const [initializedChallenger, initializedOpponent] = opponentUsername ? initiatePlayers(currentClientUsername, opponentUsername) : [null, null]\n    if (initializedChallenger && initializedOpponent) {\n      const jsonChallenger = initializedChallenger.toJSON();\n      const jsonOpponent = initializedOpponent.toJSON();\n      const message = JSON.stringify({ type: 'game-invite', challenger: jsonChallenger, opponent: jsonOpponent });\n      sendMessage(message);\n    }\n  }\n\n  return (\n    <>\n      {\n      navigateReady ? (\n        <Navigate to={`/game/${gameId}`} />\n      ) :  isLoading ? (\n          <p>Loading...</p>\n        ) : users.length > 0 ? (\n          <ul>\n            {users.map((username, index) => (\n              <li key={index}>\n                <button \n                  disabled={readyState !== ReadyState.OPEN} \n                  data-username={username} \n                  onClick={handleUsernameClick}>\n                  {username}\n                </button>\n              </li>\n            ))}\n          </ul>\n        ) : (\n          <p>No users are currently logged in.</p>\n        )\n      }\n    </>\n  )\n}","/home/jake/rem-stack/chess/client/src/pages/ActiveGamePage.tsx",[],[],[],"/home/jake/rem-stack/chess/client/src/components/ActiveGame.tsx",["121"],["122"],"import React, { useEffect, useContext, useCallback } from 'react';\nimport { Player, Piece, Pawn, Rook, Bishop, Knight, Queen, King, grid } from '../utils/game-utils'\nimport type { GameState } from '../context/GameContext'\nimport { GameContext } from \"../context/GameContext\";\nimport { useDrag, useDrop } from 'react-dnd';\nimport { svgIcons } from '../utils/svg-icons';\nimport { AuthContext } from '../context/AuthContext';\n\ninterface MoveResult {\n  isValid: boolean;\n  newState: GameState;\n  newChallenger: Player | null | undefined;\n  newOpponent: Player | null | undefined;\n}\n\nexport const ActiveGame: React.FC<{}> = () => {\n\n  const { challenger, opponent, gameState, setChallenger, setOpponent, setGameState, sendMessage, lastMessage } = useContext(GameContext);\n\n  const setPiecesOnBoard = useCallback(() => {\n    if (challenger && opponent && gameState) {\n      const allPieces = challenger.alive.concat(opponent.alive);\n      const allPositions = allPieces.map(p => p.position);\n      const newGameState: GameState = {...gameState};\n      for (const spot in newGameState.board) {\n        if (allPositions.includes(spot)) {\n          for (const p of allPieces) {\n            if (p.position === spot) {\n              if (newGameState.board) newGameState.board[spot][0] = p;\n            }\n          }\n        }\n      }\n      setGameState(newGameState);\n    }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [challenger, opponent]);\n\n  useEffect(() => {\n    setPiecesOnBoard();\n  }, [setPiecesOnBoard]);\n\n  useEffect(() => {\n\n    function handleIncomingData(data: any) {\n      if (data.type === 'move-made') {\n        const deserializedNewGameState = data.newGameState;\n    \n        // Loop over the board\n        for (const position in deserializedNewGameState.board) {\n          const square = deserializedNewGameState.board[position];\n          // If the square contains a piece, convert it back to a Piece object\n          if (square[0] !== null) {\n            deserializedNewGameState.board[position][0] = Piece.fromJSON(square[0]);\n          }\n        }\n        const deserializedNewChallenger = Player.fromJSON(data.newChallenger);\n        const deserializedNewOpponent = Player.fromJSON(data.newOpponent);\n\n        setChallenger(deserializedNewChallenger);\n        setOpponent(deserializedNewOpponent);\n        setGameState(deserializedNewGameState);\n      }\n    }\n\n    if (lastMessage !== null) {\n      if (lastMessage.data instanceof Blob) {\n        const reader = new FileReader();\n        reader.onload = () => {\n          if (typeof reader.result === 'string') {\n            const data = JSON.parse(reader.result);\n            handleIncomingData(data);\n          }\n        };\n        reader.readAsText(lastMessage.data);\n      } else {\n        const data = JSON.parse(lastMessage.data);\n        handleIncomingData(data);\n      }\n    }\n  }, [sendMessage, lastMessage, setGameState, setChallenger, setOpponent])\n\n  const renderBlackGravePiece = (piece: Piece, index: number) => (\n    <div key={index} className=\"flex items-end p-0 m-o h-auto\">{svgIcons[piece.pieceName]}</div>\n  );\n\n  const renderWhiteGravePiece = (piece: Piece, index: number) => (\n    <div key={index} className=\"flex items-start p-0 m-o h-auto\">{svgIcons[piece.pieceName]}</div>\n  );\n\n  return (\n    <>\n    <div className='flex justify-center mb-4'>\n      {challenger && opponent ? challenger.color === 'black' ? <p className=\"text-noct-blue\">{challenger.name}</p> : <p className=\"text-noct-blue\">{opponent.name}</p> : null}\n    </div>\n    <div className=\"flex\">\n      <div className='flex-1 flex flex-wrap flex-start'>\n        {\n          gameState ? (\n              gameState.moves.map((move, index, arr) => (\n                <div className='text-noct-blue flex justify-start p-0 m-0 h-auto' key={index}>\n                  {index % 2 === 0 ? `${Math.floor(index / 2) + 1}. ${move}` : `${move}`}\n                  {index < arr.length - 1 ? ',  ' : ''}\n                </div>\n              ))\n          ) : null\n        }\n      </div>\n      <ChessBoard />\n      { (challenger && opponent) ? (\n          <div className=\"flex-1 flex flex-col\">\n            <div className=\"flex-1 flex space-x-2 flex-wrap\">\n              {challenger.color === 'white' ? challenger.grave.map(renderWhiteGravePiece) : opponent.grave.map(renderWhiteGravePiece)}\n            </div>\n            <div className=\"flex-1 flex space-x-2 flex-wrap \">\n              {challenger.color === 'black' ? challenger.grave.map(renderBlackGravePiece) : opponent.grave.map(renderBlackGravePiece)}\n            </div>\n          </div>\n        ) : null\n      }\n    </div>\n    <div className='flex justify-center mt-2'>\n      {challenger && opponent ? challenger.color === 'white' ? <p className=\"text-noct-blue\">{challenger.name}</p> : <p className=\"text-noct-blue\">{opponent.name}</p>: null}\n    </div>\n    </>\n  );\n};\n\nconst ChessBoard: React.FC<{}> = () => {\n  const { gameState } = useContext(GameContext);\n  const chessBoard = [];\n\n  for (let row_num = 0; row_num < 8; row_num++) {\n    let row = [];\n    for (let col_num = 0; col_num < 8; col_num++) {\n      if (gameState) {\n        let position = grid[col_num][row_num];\n        let squareColor = row_num % 2 === 0 \n        ? col_num % 2 === 0 ? 'bg-black-square' : 'bg-white-square' \n        : col_num % 2 === 0 ? 'bg-white-square' : 'bg-black-square';\n        row.push(\n          <Square key={`${row_num}-${col_num}`} position={position} squareColor={squareColor} />\n        );\n      }\n    }\n    chessBoard.push(<div key={row_num} className=\"w-screen flex items-center justify-center\">{row}</div>);\n  }\n\n  return (\n    <div className='flex-1'> \n      {chessBoard}\n    </div>\n  );\n}\n\n// Square component\nconst Square: React.FC<{ position: string, squareColor: string }> = ({ position, squareColor }) => {\n  const { challenger, opponent, gameId, gameState, sendMessage } = useContext(GameContext);\n  const { currentClientUsername } = useContext(AuthContext)\n\n  const convertMoveToAlgebraic = (piece: Piece, start: string, end: string, capture: boolean): string => {\n    // Convert the details of the move to algebraic notation\n    if (piece instanceof Pawn) {\n      let move = (capture ? 'x' : '') + end;\n      return move;\n    }\n    const firstLetter = piece.pieceName[1].toUpperCase();\n    let move = firstLetter + (capture ? 'x' : '') + end.toLowerCase();\n    return move;\n  }\n\n  const process_move = (start: string, end: string): MoveResult => {\n    let copyState = {...gameState as GameState};\n    if (copyState.board) {\n      let startPosition = start[0] + start[1];\n      let endPosition = end[0] + end[1];\n      let startCol = copyState.board[startPosition][1];\n      let startRow = 7 - parseInt(startPosition[1]);\n    \n      let piece = copyState.board[startPosition][0];\n      // check if piece belongs to white, check the isWhite property of the piece to make sure it is a white piece white is dragging\n      //against if it is white's turn to move. \n      if (piece) {\n        if (piece.isWhite !== copyState.isWhiteTurn) {\n          return { isValid: false, newState: copyState, newChallenger: challenger, newOpponent: opponent };\n        }\n        console.log(currentClientUsername)\n        if (piece.playerName !== currentClientUsername){\n          return { isValid: false, newState: copyState, newChallenger: challenger, newOpponent: opponent };\n        }\n      }\n\n      const board = copyState.board;\n      let allMoves: string[] = [];\n      // find what kind of piece we are moving\n      if (piece instanceof Pawn) {\n          allMoves = piece.validPawnMoves(grid, board, startCol, startRow);\n      } else if (piece instanceof Knight) {\n          allMoves = piece.validKnightMoves(grid, board, startCol, startRow);\n      } else if (piece instanceof Rook) {\n          allMoves = piece.get_all_straight(grid, board, startCol, startRow);\n      } else if (piece instanceof Bishop) {\n          allMoves = piece.get_all_diagonal(grid, board, startCol, startRow);\n      } else if (piece instanceof Queen) {\n          allMoves = piece.get_all_straight(grid, board, startCol, startRow)\n              .concat(piece.get_all_diagonal(grid, board, startCol, startRow));\n      } else if (piece instanceof King) {\n          allMoves = piece.validKingMoves(grid, board, startCol, startRow);\n      }\n      \n      let didCapture = false;\n      if (allMoves.includes(endPosition)) {\n        // if the piece moving is taking an opponents piece\n        if (board[endPosition][0] !== null) {\n          didCapture = true;\n          const endSpotpiece = board[endPosition][0];\n          // update the alive and grave list for player losing a piece\n          if (endSpotpiece && challenger && opponent) {\n            if (challenger.alive.includes(endSpotpiece)) {\n              challenger.grave.push(endSpotpiece);\n              challenger.alive = challenger.alive.filter(item => item !== endSpotpiece);\n            } else {\n              opponent.grave.push(endSpotpiece);\n              opponent.alive = opponent.alive.filter(item => item !== endSpotpiece);\n            }\n          }\n        }\n\n\n        if (piece) {\n          const move = convertMoveToAlgebraic(piece, start, end, didCapture)\n          copyState.moves.push(move)\n        }\n    \n        // update the positions of the pieces on the board\n        board[endPosition][0] = board[startPosition][0];\n        board[startPosition][0] = null;\n        if (board[endPosition][0] !== null) {\n          let piece = board[endPosition][0];\n          if (piece && challenger && opponent) {\n            piece.position = endPosition;\n            if (challenger.name === piece.playerName) {\n              challenger.alive.forEach((p) => {\n                  if (p.position === startPosition) {\n                      p.position = endPosition;\n                  }\n              });\n            } else {\n              opponent.alive.forEach((p) => {\n                if (p.position === startPosition) {\n                    p.position = endPosition;\n                }\n              });\n            }\n          }\n        }\n      } else {\n        return { isValid: false, newState: copyState, newChallenger: challenger, newOpponent: opponent };\n      }\n    }\n    const newTurn = copyState.isWhiteTurn ? false : true;\n    copyState.isWhiteTurn = newTurn;\n    return { isValid: true, newState: copyState, newChallenger: challenger, newOpponent: opponent };\n  }\n\n  const [, dropRef] = useDrop({\n    accept: 'piece',\n    drop: (item: any, monitor) => {\n      if (item) {\n        const start = item.piece.position; \n        const end = position;\n        if (challenger && opponent) {\n          const moveResult = process_move(start, end);\n          if (moveResult.isValid) {\n            if (moveResult.newChallenger && moveResult.newOpponent) {\n              item.piece.moved = true;\n              const jsonNewChallenger = moveResult.newChallenger.toJSON();\n              const jsonNewOpponent = moveResult.newOpponent.toJSON();\n              const message = JSON.stringify({\n                type: 'valid-move', \n                pieceColor: item.piece.isWhite, \n                playerName: item.piece.playerName, \n                gameId: gameId, \n                newGameState: moveResult.newState, \n                newChallenger: jsonNewChallenger, \n                newOpponent: jsonNewOpponent \n              })\n              sendMessage(message)\n            }\n          }\n          else {\n            alert('inValid Move');\n          }\n        }\n      }\n    },\n  })\n\n  const piece = gameState ? gameState.board[position][0] : null;\n\n  return (\n    <div ref={dropRef} className={`w-square h-square flex items-center justify-center ${squareColor}`}>\n      {piece ? <DraggablePiece piece={piece} /> : null}\n    </div>\n  );\n};\n\nconst DraggablePiece: React.FC<{ piece: Piece }> = ({ piece }) => {\n  const [{ isDragging }, dragRef] = useDrag({\n    type: 'piece',\n    item: { type: 'piece', piece },\n    collect: monitor => ({\n      isDragging: !!monitor.isDragging(),\n    }),\n  })\n\n  return (\n    <div ref={dragRef}>\n      {svgIcons[piece.pieceName]}\n    </div>\n  )\n}\n","/home/jake/rem-stack/chess/client/src/pages/NewUserRedirectVerifyEmail.tsx",[],[],"/home/jake/rem-stack/chess/client/src/utils/game-utils.ts",[],[],"/home/jake/rem-stack/chess/client/src/context/GameContext.tsx",["123"],[],"import { createContext, useState, ReactNode, useEffect, useContext, useCallback } from 'react';\nimport useWebSocket, { ReadyState } from 'react-use-websocket';\nimport { Player, assignBlackPieces, assignWhitePieces } from '../utils/game-utils';\nimport { Piece, grid } from '../utils/game-utils';\nimport { JsonObject } from 'react-use-websocket/dist/lib/types';\nimport { AuthContext } from './AuthContext';\n\nexport interface StartGameMessageObject extends JsonObject {\n  type: string;\n  accepted?: boolean;\n  challenger: string;\n  opponent: string;\n  gameId?: string;\n}\n\nexport interface GameState {\n  board: {\n    [key: string]: [Piece | null, number];\n  };\n  isWhiteTurn: boolean;\n  moves: string[];\n}\n\ntype GameContextType = {\n  challenger: Player | undefined;\n  opponent: Player | undefined;\n  gameId: string;\n  gameState: GameState | undefined;\n  setGameId: React.Dispatch<React.SetStateAction<string>>;\n  setChallenger: React.Dispatch<React.SetStateAction<Player | undefined>>;\n  setOpponent: React.Dispatch<React.SetStateAction<Player | undefined>>;\n  setGameState: React.Dispatch<React.SetStateAction<GameState>>;\n  sendMessage: (message: string) => void;\n  lastMessage: MessageEvent<any> | null;\n  readyState: ReadyState;\n  initiatePlayers: (challengerUsername: string, opponentUsername: string) => Player[];\n};\n\nexport const GameContext = createContext<GameContextType>({\n  challenger: undefined,\n  opponent: undefined,\n  gameId: '',\n  gameState: undefined,\n  setGameId: () => { },\n  setChallenger: () => { },\n  setOpponent: () => { },\n  setGameState: () => { },\n  sendMessage: () => {},  // default function\n  lastMessage: null,\n  readyState: ReadyState.UNINSTANTIATED,\n  initiatePlayers: () => [],\n});\n\ntype GameProviderProps = {\n  children: ReactNode;\n};\n\nconst produceInitialGameState = () => {\n  let cordCount = 0;\n  const newGameState: GameState = {board: {}, isWhiteTurn: true, moves: []};\n  for (const col of grid) {\n    for (const cord of col) {\n      newGameState.board[cord] = [null, cordCount];\n    }\n    cordCount += 1;\n  }\n  return newGameState;\n}\n\nexport const GameProvider: React.FC<GameProviderProps> = ({ children }) => {\n  const initialState: GameState = produceInitialGameState();\n\n  const [challenger, setChallenger] = useState<Player | undefined>(undefined);\n  const [opponent, setOpponent] = useState<Player | undefined>(undefined);\n  const [gameId, setGameId] = useState<string>('');\n  const [gameState, setGameState] = useState<GameState>(initialState);\n  const { isLoggedIn } = useContext(AuthContext)\n  const [socketUrl, setSocketUrl] = useState<string>('');\n\n  const initiatePlayers = (challengerUsername: string, opponentUsername: string): Player[] =>  {\n    let player1 = new Player(challengerUsername, '', [], []);\n    let player2 = new Player(opponentUsername, '', [], []);\n    const r = Math.floor(Math.random() * 2);\n    if (r === 0) {\n      player1.color = 'white';\n      player2.color = 'black';\n      assignWhitePieces(player1);\n      assignBlackPieces(player2);\n    } else {\n      player1.color = 'black';\n      player2.color = 'white';\n      assignWhitePieces(player2);\n      assignBlackPieces(player1);\n    }\n    return [player1, player2];\n  }\n  \n  useEffect(() => {\n    if (isLoggedIn) {\n      setSocketUrl('ws://localhost:3001');\n    }\n  }, [isLoggedIn]);\n\n  const {\n    sendMessage,\n    lastMessage,\n    readyState\n  } = useWebSocket<StartGameMessageObject>(socketUrl, {\n    onOpen: () => console.log('opened'),\n    shouldReconnect: (closeEvent) => true,\n  }, socketUrl !== '');\n\n  return (\n    <GameContext.Provider value={{ challenger, opponent, gameId, gameState, setGameId, setChallenger, setOpponent, setGameState, sendMessage, lastMessage, readyState, initiatePlayers }}>\n      {children}\n    </GameContext.Provider>\n  );\n};","/home/jake/rem-stack/chess/client/src/utils/svg-icons.tsx",[],[],{"ruleId":"124","severity":1,"message":"125","line":1,"column":14,"nodeType":"126","messageId":"127","endLine":1,"endColumn":23},{"ruleId":"124","severity":1,"message":"128","line":1,"column":25,"nodeType":"126","messageId":"127","endLine":1,"endColumn":33},{"ruleId":"124","severity":1,"message":"129","line":1,"column":14,"nodeType":"126","messageId":"127","endLine":1,"endColumn":25},{"ruleId":"124","severity":1,"message":"130","line":309,"column":12,"nodeType":"126","messageId":"127","endLine":309,"endColumn":22},{"ruleId":"131","severity":1,"message":"132","line":37,"column":6,"nodeType":"133","endLine":37,"endColumn":28,"suggestions":"134","suppressions":"135"},{"ruleId":"124","severity":1,"message":"129","line":1,"column":69,"nodeType":"126","messageId":"127","endLine":1,"endColumn":80},"@typescript-eslint/no-unused-vars","'useEffect' is defined but never used.","Identifier","unusedVar","'useState' is defined but never used.","'useCallback' is defined but never used.","'isDragging' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useCallback has missing dependencies: 'gameState' and 'setGameState'. Either include them or remove the dependency array.","ArrayExpression",["136"],["137"],{"desc":"138","fix":"139"},{"kind":"140","justification":"141"},"Update the dependencies array to be: [challenger, gameState, opponent, setGameState]",{"range":"142","text":"143"},"directive","",[1426,1448],"[challenger, gameState, opponent, setGameState]"]