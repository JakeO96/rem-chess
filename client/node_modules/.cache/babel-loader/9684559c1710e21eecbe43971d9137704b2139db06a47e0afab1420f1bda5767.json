{"ast":null,"code":"var _jsxFileName = \"/home/jake/rem-stack/chess/client/src/components/ActiveGame.tsx\",\n  _s = $RefreshSig$();\nimport { assignBlackPieces, assignWhitePieces } from '../utils/game-utils';\nimport React, { useState, useEffect } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ActiveGame = _ref => {\n  _s();\n  let {\n    player1,\n    player2\n  } = _ref;\n  const [gameState, setGameState] = useState({});\n  useEffect(() => {\n    produceEmptyBoard();\n    randomlyAssignWhite();\n    setPiecesOnBoard();\n  }, []);\n  const produceEmptyBoard = () => {\n    let cCnt = 0;\n    const newGameState = {};\n    for (const col of grid) {\n      for (const cord of col) {\n        newGameState[cord] = [null, cCnt];\n      }\n      cCnt += 1;\n    }\n    setGameState(newGameState);\n  };\n  const randomlyAssignWhite = () => {\n    const r = Math.floor(Math.random() * 2);\n    if (r === 0) {\n      assignWhitePieces(grid, player1);\n      player1.color = 'white';\n      assignBlackPieces(grid, player2);\n      player2.color = 'black';\n    } else {\n      assignWhitePieces(grid, player2);\n      player2.color = 'white';\n      assignBlackPieces(grid, player1);\n      player1.color = 'black';\n    }\n  };\n  const setPiecesOnBoard = () => {\n    const allPieces = player1.alive.concat(player2.alive);\n    const allPositions = allPieces.map(p => p.position);\n    const newGameState = {\n      ...gameState\n    };\n    for (const spot in newGameState) {\n      if (allPositions.includes(spot)) {\n        for (const p of allPieces) {\n          if (p.position === spot) {\n            newGameState[spot][0] = p;\n          }\n        }\n      }\n    }\n    setGameState(newGameState);\n  };\n  const renderBoard = () => {\n    // This function should return JSX that represents the board.\n    // This implementation depends on how you want to render the board.\n    // For simplicity, let's assume we're returning an empty div.\n    return /*#__PURE__*/_jsxDEV(\"div\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 12\n    }, this);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: renderBoard()\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 74,\n    columnNumber: 5\n  }, this);\n};\n_s(ActiveGame, \"b1N0qf7c+YN/lg5dRubxKOxv8uY=\");\n_c = ActiveGame;\nvar _c;\n$RefreshReg$(_c, \"ActiveGame\");","map":{"version":3,"names":["assignBlackPieces","assignWhitePieces","React","useState","useEffect","jsxDEV","_jsxDEV","ActiveGame","_ref","_s","player1","player2","gameState","setGameState","produceEmptyBoard","randomlyAssignWhite","setPiecesOnBoard","cCnt","newGameState","col","grid","cord","r","Math","floor","random","color","allPieces","alive","concat","allPositions","map","p","position","spot","includes","renderBoard","fileName","_jsxFileName","lineNumber","columnNumber","children","_c","$RefreshReg$"],"sources":["/home/jake/rem-stack/chess/client/src/components/ActiveGame.tsx"],"sourcesContent":["import MainLayout from \"./MainLayout\"\nimport { Player, Piece, Pawn, Rook, Knight, Bishop, Queen, King, assignBlackPieces, assignWhitePieces, processMove } from '../utils/game-utils'\nimport React, { useState, useEffect } from 'react';\n\ninterface GameState {\n  [key: string]: [Piece | null, number];\n}\n\ninterface ActiveGameProps {\n  player1: Player;\n  player2: Player;\n}\n\nexport const ActiveGame: React.FC<ActiveGameProps> = ({ player1, player2 }) => {\n  const [gameState, setGameState] = useState<GameState>({});\n\n  useEffect(() => {\n    produceEmptyBoard();\n    randomlyAssignWhite();\n    setPiecesOnBoard();\n  }, []);\n\n  const produceEmptyBoard = () => {\n    let cCnt = 0;\n    const newGameState: GameState = {};\n    for (const col of grid) {\n      for (const cord of col) {\n        newGameState[cord] = [null, cCnt];\n      }\n      cCnt += 1;\n    }\n    setGameState(newGameState);\n  }\n\n  const randomlyAssignWhite = () => {\n    const r = Math.floor(Math.random() * 2);\n    if (r === 0) {\n      assignWhitePieces(grid, player1);\n      player1.color = 'white';\n      assignBlackPieces(grid, player2);\n      player2.color = 'black';\n    } else {\n      assignWhitePieces(grid, player2);\n      player2.color = 'white';\n      assignBlackPieces(grid, player1);\n      player1.color = 'black';\n    }\n  }\n\n  const setPiecesOnBoard = () => {\n    const allPieces = player1.alive.concat(player2.alive);\n    const allPositions = allPieces.map(p => p.position);\n    const newGameState = {...gameState};\n    for (const spot in newGameState) {\n      if (allPositions.includes(spot)) {\n        for (const p of allPieces) {\n          if (p.position === spot) {\n            newGameState[spot][0] = p;\n          }\n        }\n      }\n    }\n    setGameState(newGameState);\n  }\n\n  const renderBoard = (): JSX.Element => {\n    // This function should return JSX that represents the board.\n    // This implementation depends on how you want to render the board.\n    // For simplicity, let's assume we're returning an empty div.\n    return <div></div>;\n  }\n\n  return (\n    <div>\n      {renderBoard()}\n    </div>\n  );\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}